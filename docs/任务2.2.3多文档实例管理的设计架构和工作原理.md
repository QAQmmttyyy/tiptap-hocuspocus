
我来用图示详细解释任务2.2.3多文档实例管理的设计架构和工作原理。

## 🏗️ 多文档实例管理系统架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                    用户界面层 (UI Layer)                        │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │
│  │  标签页1    │  │  标签页2    │  │  标签页3    │             │
│  │ 文档A.md    │  │ 文档B.md    │  │ 文档C.md    │             │
│  │ [活跃中]    │  │ [非活跃]    │  │ [暂停中]    │             │
│  └─────────────┘  └─────────────┘  └─────────────┘             │
└──────────────────────┬──────────────────────────────────────────┘
                       │ useDocumentInstances Hook
                       ▼
┌─────────────────────────────────────────────────────────────────┐
│                 文档实例管理器 (DocumentInstanceManager)        │
│                         [单例模式]                              │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │                   实例映射表                                ││
│  │  documentA-tab1 → DocumentInstance {                       ││
│  │    id: "doc-a-tab1"                                        ││
│  │    status: "active"                                        ││
│  │    editor: EditorInstance                                  ││
│  │    connection: ConnectionInstance                          ││
│  │    priority: 5                                             ││
│  │  }                                                         ││
│  └─────────────────────────────────────────────────────────────┘│
└──────────────┬──────────────┬──────────────┬───────────────────┘
               │              │              │
               ▼              ▼              ▼
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│  内存优化器     │ │   连接池        │ │  编辑器池       │
│ MemoryOptimizer │ │ ConnectionPool  │ │  EditorPool     │
│                 │ │                 │ │                 │
│ 📊 监控内存使用 │ │ 🔗 管理WS连接   │ │ ✏️ 管理编辑器   │
│ 🧹 LRU清理算法  │ │ ♻️ 连接复用     │ │ ⏸️ 暂停/恢复    │
│ ⚠️ 阈值告警     │ │ 🔄 断线重连     │ │ 💾 内存估算     │
│ 💡 优化建议     │ │ 📈 状态跟踪     │ │ 🔄 实例复用     │
└─────────────────┘ └─────────────────┘ └─────────────────┘
         │                    │                    │
         ▼                    ▼                    ▼
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│   Yjs文档       │ │ HocuspocusProvider│ │  Tiptap编辑器   │
│   Y.Doc         │ │  WebSocket连接   │ │   Editor实例    │
│   协作数据      │ │  实时同步        │ │   DOM渲染       │
└─────────────────┘ └─────────────────┘ └─────────────────┘
```

## 🎯 核心设计理念

### 1. **分层管理架构**
```
用户操作 → Hook集成 → 实例管理器 → 三大池管理器 → 底层资源
```

### 2. **三大池管理器**

#### 🧠 **内存优化器 (MemoryOptimizer)**
```
职责：智能内存管理
┌─────────────────────────────────┐
│ 📊 实时监控：                   │
│   - 总内存使用：150MB/200MB     │
│   - 活跃实例：3个               │
│   - 暂停实例：2个               │
│                                 │
│ 🧹 LRU清理算法：               │
│   - 30分钟未使用 → 自动清理     │
│   - 内存超限 → 强制清理         │
│                                 │
│ 💡 优化建议：                   │
│   - "文档C已30分钟未访问"       │
│   - "建议暂停文档B释放内存"     │
└─────────────────────────────────┘
```

#### 🔗 **连接池 (ConnectionPool)**
```
职责：WebSocket连接管理
┌─────────────────────────────────┐
│ ♻️ 连接复用：                   │
│   document-A → connection-1     │
│   document-A-tab2 → connection-1│ (共享)
│                                 │
│ 🔄 断线重连：                   │
│   - 指数退避：2s → 4s → 8s      │
│   - 最大重试：3次               │
│                                 │
│ ⏸️ 暂停机制：                   │
│   - 无活跃标签页 → 暂停连接     │
│   - 需要时自动恢复              │
└─────────────────────────────────┘
```

#### ✏️ **编辑器池 (EditorPool)**
```
职责：Tiptap编辑器实例管理
┌─────────────────────────────────┐
│ 🎯 编辑器生命周期：             │
│   创建 → 活跃 → 非活跃 → 暂停 → 销毁│
│                                 │
│ ⏸️ 暂停/恢复：                  │
│   - 非活跃标签页 → 暂停编辑器   │
│   - 释放DOM和内存               │
│   - 切换回来 → 快速恢复         │
│                                 │
│ 💾 内存估算：                   │
│   基础3MB + 内容长度/10KB*1MB   │
└─────────────────────────────────┘
```

## 🔄 工作流程示例

### 场景1：用户打开新文档
```
1. 用户点击侧边栏文档A
   ↓
2. TabStore创建新标签页
   ↓
3. useDocumentInstances.createDocumentInstance()
   ↓
4. DocumentInstanceManager.getDocumentInstance()
   ↓
5. 并行创建：
   ├─ ConnectionPool.getOrCreateConnection() → WebSocket连接
   ├─ EditorPool.getOrCreateEditor() → Tiptap编辑器
   └─ MemoryOptimizer.updateStats() → 更新内存统计
   ↓
6. 返回DocumentInstance给用户界面
```

### 场景2：标签页切换（性能优化）
```
标签页A（活跃）→ 标签页B（切换）

TabA状态变化：
active → inactive → 延迟5秒 → paused
[编辑器暂停，释放DOM，保留数据]

TabB状态变化：
paused → 检查连接 → 恢复编辑器 → active
[快速恢复，用户几乎无感知]
```

### 场景3：内存不足自动清理
```
系统检测：内存使用 210MB > 阈值 200MB
   ↓
MemoryOptimizer启动LRU清理：
   ↓
1. 查找最旧的非活跃实例：文档C (30分钟前访问)
2. 销毁实例：编辑器 + 连接 + 文档实例
3. 内存释放：210MB → 180MB
4. 发出清理事件通知
```

## 🎭 实例状态转换图

```
文档实例生命周期：

    创建
     ↓
┌──[idle]──┐
│          │
│  初始化   │ ←──┐
│          │    │
└────┬─────┘    │
     ↓          │
  [active] ←────┼─── 标签页激活
     ↕          │
[inactive] ──────┤    标签页切换
     ↓          │
  [paused] ──────┤    长时间未用
     ↓          │
[destroyed]      │    超出限制/手动关闭
                 │
              恢复时重新创建
```

## 💡 为什么需要这样设计？

### 🎯 **解决的核心问题**

1. **内存泄漏防护**
   ```
   问题：多个文档同时打开，内存持续增长
   解决：LRU清理 + 暂停机制 + 内存监控
   ```

2. **连接资源优化**
   ```
   问题：每个标签页独立连接，浪费资源
   解决：连接池复用 + 智能暂停
   ```

3. **编辑器性能优化**
   ```
   问题：大量DOM节点影响页面性能
   解决：非活跃编辑器暂停 + 按需恢复
   ```

4. **用户体验保障**
   ```
   问题：标签页切换卡顿
   解决：暂停而非销毁 + 快速恢复机制
   ```

### 🚀 **带来的优势**

- **🔥 性能提升**：内存使用控制在200MB以内
- **⚡ 响应迅速**：标签页切换<100ms
- **🛡️ 资源安全**：防止内存泄漏和连接泄漏
- **🎯 智能管理**：自动清理 + 优化建议
- **🔧 易于维护**：分层架构 + 事件驱动

## 🎪 实际使用效果

```typescript
// 在组件中使用
const { 
  createDocumentInstance,    // 创建文档实例
  getEditorInstance,         // 获取编辑器
  getInstanceStats           // 获取统计信息
} = useDocumentInstances()

// 系统自动处理：
// ✅ 标签页关闭 → 自动销毁实例
// ✅ 标签页切换 → 自动暂停/激活
// ✅ 内存超限 → 自动清理最旧实例
// ✅ 连接断开 → 自动重连
```

这个系统就像一个智能的"文档管家"，自动管理所有复杂的资源分配和回收，让用户专注于内容创作，而不用担心性能问题！ 🎯
